<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy Explorer - Space Arcade Game</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        const GalaxyExplorer = () => {
          const canvasRef = useRef(null);
          const [gameOver, setGameOver] = useState(false);
          const [score, setScore] = useState(0);
          const [highScore, setHighScore] = useState(0);
          
          const gameStateRef = useRef({
            player: { x: 400, y: 300, size: 30 },
            obstacles: [],
            powerups: [],
            mouseX: 400,
            mouseY: 300,
            score: 0,
            gameTime: 0,
            animationId: null,
            explosionParticles: []
          });

          useEffect(() => {
            const canvas = canvasRef.current;
            const ctx = canvas.getContext('2d');
            const state = gameStateRef.current;

            const handleMouseMove = (e) => {
              const rect = canvas.getBoundingClientRect();
              state.mouseX = e.clientX - rect.left;
              state.mouseY = e.clientY - rect.top;
            };

            canvas.addEventListener('mousemove', handleMouseMove);

            const spawnObstacle = () => {
              const side = Math.floor(Math.random() * 4);
              let x, y, vx, vy;
              
              const baseSpeed = 2 + state.gameTime / 10;
              
              if (side === 0) { // Top
                x = Math.random() * canvas.width;
                y = -30;
                vx = (Math.random() - 0.5) * baseSpeed;
                vy = Math.random() * baseSpeed + 1;
              } else if (side === 1) { // Right
                x = canvas.width + 30;
                y = Math.random() * canvas.height;
                vx = -(Math.random() * baseSpeed + 1);
                vy = (Math.random() - 0.5) * baseSpeed;
              } else if (side === 2) { // Bottom
                x = Math.random() * canvas.width;
                y = canvas.height + 30;
                vx = (Math.random() - 0.5) * baseSpeed;
                vy = -(Math.random() * baseSpeed + 1);
              } else { // Left
                x = -30;
                y = Math.random() * canvas.height;
                vx = Math.random() * baseSpeed + 1;
                vy = (Math.random() - 0.5) * baseSpeed;
              }

              const types = ['asteroid', 'debris', 'satellite'];
              const type = types[Math.floor(Math.random() * types.length)];
              const size = type === 'satellite' ? 25 : Math.random() * 20 + 15;

              state.obstacles.push({ x, y, vx, vy, size, type, rotation: 0 });
            };

            const spawnPowerup = () => {
              // Only spawn if no powerup currently exists
              if (state.powerups.length > 0) return;
              
              const side = Math.floor(Math.random() * 4);
              let x, y, vx, vy;
              
              const speed = 1.5;
              
              if (side === 0) { // Top
                x = Math.random() * canvas.width;
                y = -30;
                vx = (Math.random() - 0.5) * speed;
                vy = Math.random() * speed + 0.5;
              } else if (side === 1) { // Right
                x = canvas.width + 30;
                y = Math.random() * canvas.height;
                vx = -(Math.random() * speed + 0.5);
                vy = (Math.random() - 0.5) * speed;
              } else if (side === 2) { // Bottom
                x = Math.random() * canvas.width;
                y = canvas.height + 30;
                vx = (Math.random() - 0.5) * speed;
                vy = -(Math.random() * speed + 0.5);
              } else { // Left
                x = -30;
                y = Math.random() * canvas.height;
                vx = Math.random() * speed + 0.5;
                vy = (Math.random() - 0.5) * speed;
              }
              
              state.powerups.push({ x, y, vx, vy, size: 30, pulse: 0 });
            };

            const createExplosion = (x, y) => {
              for (let i = 0; i < 30; i++) {
                const angle = (Math.PI * 2 * i) / 30;
                const speed = Math.random() * 5 + 3;
                state.explosionParticles.push({
                  x, y,
                  vx: Math.cos(angle) * speed,
                  vy: Math.sin(angle) * speed,
                  life: 1
                });
              }
            };

            const checkCollision = (obj1, obj2) => {
              const dx = obj1.x - obj2.x;
              const dy = obj1.y - obj2.y;
              const distance = Math.sqrt(dx * dx + dy * dy);
              return distance < (obj1.size + obj2.size) / 2;
            };

            const drawPlayer = () => {
              ctx.save();
              ctx.translate(state.player.x, state.player.y);
              
              // Astronaut body
              ctx.fillStyle = '#FFFFFF';
              ctx.beginPath();
              ctx.arc(0, 0, 12, 0, Math.PI * 2);
              ctx.fill();
              
              // Helmet
              ctx.strokeStyle = '#87CEEB';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.arc(0, 0, 13, 0, Math.PI * 2);
              ctx.stroke();
              
              // Visor
              ctx.fillStyle = '#4A90E2';
              ctx.beginPath();
              ctx.arc(0, -2, 6, 0, Math.PI * 2);
              ctx.fill();
              
              // Body suit
              ctx.fillStyle = '#E0E0E0';
              ctx.fillRect(-8, 8, 16, 12);
              
              // Arms
              ctx.fillRect(-14, 10, 6, 8);
              ctx.fillRect(8, 10, 6, 8);
              
              // Jetpack
              ctx.fillStyle = '#FF6B6B';
              ctx.fillRect(-6, 18, 12, 6);
              
              ctx.restore();
            };

            const drawObstacle = (obs) => {
              ctx.save();
              ctx.translate(obs.x, obs.y);
              ctx.rotate(obs.rotation);

              if (obs.type === 'asteroid') {
                ctx.fillStyle = '#8B7355';
                ctx.beginPath();
                for (let i = 0; i < 8; i++) {
                  const angle = (i / 8) * Math.PI * 2;
                  const radius = obs.size / 2 + Math.random() * 5;
                  const x = Math.cos(angle) * radius;
                  const y = Math.sin(angle) * radius;
                  if (i === 0) ctx.moveTo(x, y);
                  else ctx.lineTo(x, y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                ctx.stroke();
              } else if (obs.type === 'debris') {
                ctx.fillStyle = '#B0B0B0';
                ctx.fillRect(-obs.size / 2, -obs.size / 2, obs.size, obs.size);
                ctx.strokeStyle = '#606060';
                ctx.lineWidth = 2;
                ctx.strokeRect(-obs.size / 2, -obs.size / 2, obs.size, obs.size);
              } else if (obs.type === 'satellite') {
                ctx.fillStyle = '#FFD700';
                ctx.fillRect(-obs.size / 3, -obs.size / 3, obs.size / 1.5, obs.size / 1.5);
                ctx.fillStyle = '#4A90E2';
                ctx.fillRect(-obs.size / 2, -3, obs.size, 6);
                ctx.fillRect(-3, -obs.size / 2, 6, obs.size);
              }

              ctx.restore();
            };

            const drawPowerup = (powerup) => {
              ctx.save();
              ctx.translate(powerup.x, powerup.y);
              
              // Pulsing effect
              const scale = 1 + Math.sin(powerup.pulse) * 0.2;
              ctx.scale(scale, scale);
              
              // Draw golden star
              ctx.fillStyle = '#FFD700';
              ctx.strokeStyle = '#FFA500';
              ctx.lineWidth = 2;
              ctx.beginPath();
              for (let i = 0; i < 5; i++) {
                const angle = (i * 4 * Math.PI) / 5 - Math.PI / 2;
                const radius = i % 2 === 0 ? powerup.size / 2 : powerup.size / 4;
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              }
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
              
              // Glow effect
              ctx.shadowBlur = 20;
              ctx.shadowColor = '#FFD700';
              ctx.fill();
              
              ctx.restore();
            };

            const gameLoop = () => {
              // Clear canvas
              ctx.fillStyle = '#000814';
              ctx.fillRect(0, 0, canvas.width, canvas.height);

              // Draw stars
              ctx.fillStyle = '#FFFFFF';
              for (let i = 0; i < 100; i++) {
                const x = (i * 137.5) % canvas.width;
                const y = (i * 149.3) % canvas.height;
                ctx.fillRect(x, y, 2, 2);
              }

              // Move player towards mouse
              const dx = state.mouseX - state.player.x;
              const dy = state.mouseY - state.player.y;
              state.player.x += dx * 0.1;
              state.player.y += dy * 0.1;

              // Update obstacles
              state.obstacles = state.obstacles.filter(obs => {
                obs.x += obs.vx;
                obs.y += obs.vy;
                obs.rotation += 0.02;

                // Remove if off screen
                if (obs.x < -50 || obs.x > canvas.width + 50 || 
                    obs.y < -50 || obs.y > canvas.height + 50) {
                  return false;
                }

                // Check collision
                if (checkCollision(state.player, obs)) {
                  setGameOver(true);
                  setScore(Math.floor(state.score));
                  if (state.score > highScore) {
                    setHighScore(Math.floor(state.score));
                  }
                  return true;
                }

                drawObstacle(obs);
                return true;
              });

              // Update powerups
              state.powerups = state.powerups.filter(powerup => {
                powerup.x += powerup.vx;
                powerup.y += powerup.vy;
                powerup.pulse += 0.1;
                
                // Remove if off screen
                if (powerup.x < -50 || powerup.x > canvas.width + 50 || 
                    powerup.y < -50 || powerup.y > canvas.height + 50) {
                  return false;
                }
                
                // Check if player collected it
                if (checkCollision(state.player, powerup)) {
                  // Clear all obstacles and create explosions
                  state.obstacles.forEach(obs => {
                    createExplosion(obs.x, obs.y);
                  });
                  state.obstacles = [];
                  return false;
                }
                
                drawPowerup(powerup);
                return true;
              });

              // Update and draw explosion particles
              state.explosionParticles = state.explosionParticles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life -= 0.02;
                
                if (particle.life > 0) {
                  ctx.fillStyle = `rgba(255, 215, 0, ${particle.life})`;
                  ctx.fillRect(particle.x - 2, particle.y - 2, 4, 4);
                  return true;
                }
                return false;
              });

              // Draw player
              drawPlayer();

              // Update score and game time
              state.score += 0.1;
              state.gameTime += 0.016;

              // Spawn obstacles based on difficulty
              const spawnRate = Math.max(0.01, 0.03 - state.gameTime / 1000);
              if (Math.random() < spawnRate) {
                spawnObstacle();
              }

              // Spawn powerups occasionally (much less frequently)
              if (Math.random() < 0.0003) {
                spawnPowerup();
              }

              // Draw score
              ctx.fillStyle = '#FFFFFF';
              ctx.font = 'bold 24px Arial';
              ctx.fillText(`Score: ${Math.floor(state.score)}`, 20, 40);
              ctx.font = '16px Arial';
              ctx.fillText(`High Score: ${highScore}`, 20, 65);

              if (!gameOver) {
                state.animationId = requestAnimationFrame(gameLoop);
              }
            };

            if (!gameOver) {
              gameLoop();
            }

            return () => {
              canvas.removeEventListener('mousemove', handleMouseMove);
              if (state.animationId) {
                cancelAnimationFrame(state.animationId);
              }
            };
          }, [gameOver, highScore]);

          const resetGame = () => {
            const state = gameStateRef.current;
            state.player = { x: 400, y: 300, size: 30 };
            state.obstacles = [];
            state.powerups = [];
            state.explosionParticles = [];
            state.score = 0;
            state.gameTime = 0;
            setGameOver(false);
            setScore(0);
          };

          return (
            <div className="flex flex-col items-center justify-center min-h-screen bg-gray-900 p-4">
              <h1 className="text-4xl font-bold text-white mb-4">ðŸš€ Galaxy Explorer ðŸŒŸ</h1>
              <p className="text-gray-300 mb-4">Move your mouse to guide the astronaut and dodge space objects!</p>
              
              <div className="relative">
                <canvas
                  ref={canvasRef}
                  width={800}
                  height={600}
                  className="border-4 border-blue-400 rounded-lg shadow-2xl"
                  style={{ cursor: 'none' }}
                />
                
                {gameOver && (
                  <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-75 rounded-lg">
                    <div className="text-center">
                      <h2 className="text-5xl font-bold text-red-500 mb-4">Game Over!</h2>
                      <p className="text-2xl text-white mb-2">Score: {score}</p>
                      <p className="text-xl text-yellow-400 mb-6">High Score: {highScore}</p>
                      <button
                        onClick={resetGame}
                        className="bg-blue-500 hover:bg-blue-600 text-white font-bold py-3 px-8 rounded-lg text-xl transition-colors"
                      >
                        Play Again
                      </button>
                    </div>
                  </div>
                )}
              </div>
              
              <div className="mt-4 text-gray-400 text-sm">
                <p>ðŸ’¡ Tip: The difficulty increases over time - how long can you survive?</p>
              </div>
            </div>
          );
        };

        ReactDOM.render(<GalaxyExplorer />, document.getElementById('root'));
    </script>
</body>
</html>
